open Grammar;;
open Trie;;

let starts_with (sub:string) (st:string) : bool = 
  let sub_ln = String.length sub in
  if sub_ln > String.length st then false
  else (
	 if String.sub st 0 sub_ln = sub then true
	 else false
  );;

let symbol_var_name ((s,b):string*bool) : string = s;;

let numbered (xs:'a list) : ('a*int) list =
  let n = ref 0 in
  List.map (fun x -> incr n; x,!n) xs;;

let starts_with_nonterminal (ss:Grammar.symbol list) : bool = 
  match ss with [] -> false | s::ss' -> not (Grammar.is_terminal s);;

let svn_pos (ss:Grammar.symbol list) (s:string) : int = 
  let n = ref 0 in 
  let n' = ref 0 in 
  if not (starts_with_nonterminal ss) then incr n;
  List.iter(fun s' ->
	 incr n;
	 if symbol_var_name s' = s then n' := !n;
  ) ss; !n';;


let dump_nm = "gviz_";;

let rec dump_gviz (g:Grammar.grammar) = 
  match g with Grammar.Grammar(_,name,_,_,ps,_,t,_) ->
	 let ofile = open_out (name ^ "_gviz.ml") in
	 let os = output_string ofile in
	 let n = ref "" in
	 let num_same_nonterm = ref 1 in
	 let cap_name = String.capitalize name in
	 os "(* auto-generated by gt *)\n\n";
	 os "open ";
	 os cap_name;
	 os "_syntax;;

let cur_line = ref 1;;
let del = ref 0;;
let rec print_new_line (os:string->unit) (do_print:bool) (p:int) : unit =
   if(p > !cur_line && do_print) then ( 
      os \"\\n\"; 
      incr cur_line;
      print_new_line os do_print p;
   );;

";
	 let num = ref false in

	 os "
let rec dummy () = ()
and gviz_terminal (os:string->unit) (to_pretty_print:bool) (cons:string) = function
   (d,str1) -> 
      print_new_line os to_pretty_print (fst d); let str1 = let st = ref \"\" in 
      String.iter(fun s -> if(s = '\"') then( st := ((!st)^\"\\\\\"^(Char.escaped s)))
      else (st := ((!st)^(Char.escaped s)))) str1; !st in os str1"; 

	 let rec itr ps = 
		match ps with
			 [] -> ()
		  | (Grammar.Production(c,s,ss,ssop))::tl ->
			 let con = ref 0 in
			 let has_ors = match ssop with None -> false | _ -> true in
			 let i = ref 0 in
			 let prods ss = 
				let i' = string_of_int !i in
				incr i;
				if (s <> !n) then (
				  if (!num_same_nonterm > 1) then os "";
				  num_same_nonterm := 1;
				  n := s;
				  os "\n\nand ";
				  os ("gviz_" ^ (symbol_var_name (s,false)));
				  os " (os:string->unit) (to_pretty_print:bool) (cons:string) = function "
				)
				else incr num_same_nonterm; os "\n   |";
				
				let ss' = 
				  if starts_with "List_Left" c then 
					 let li = numbered ss in
					 if List.length li > 1 then (List.tl li)@(List.hd li)::[]
					 else li
				  else numbered ss
				in

				let var_pos = ref (svn_pos ss s) in
				let is_list = 
				  starts_with "List_Left" c || 
					 starts_with "List_Right" c 
				in
				let is_opt = starts_with "Option" c in
				
				let emit_pattern n = 
				  let print_pattern k = 
					 if not(is_opt) && not(is_list) then (
						if has_ors then os (c^i')
						else os c
					 );
					 if k mod 2 = 1 || k = 0 then os " (d" else os " (d'";
					 
					 let ss' = 
						if starts_with "List_Left" c then 
						  let li = (numbered ss) in
						  (List.tl li)@(List.hd li)::[]
						else numbered ss
					 in
					 
					 let c' = ref 0 in 

					 let first = ref true in
					 List.iter (fun (s',n) ->
						let x_i =
						  if Grammar.is_terminal s' then (
							 if Grammar.is_in_ast t s' then "str"^string_of_int n
							 else "pd"^string_of_int n
						  )
						  else symbol_var_name s' ^ string_of_int n 
						in
						incr c';
						if !c' = List.length ss' && is_list then os ")::" else os " , ";
						if !first && (is_opt || is_list) then (
						  first := false;
						  if is_opt then os "Some"; os "("
						);
						if k = 0 then os x_i 
						else os (x_i^"_"^(string_of_int k))
					 ) ss';
					 
					 os ")"; if List.length ss <> 0 && is_opt then os ")"; in				
				  
				  if List.length ss = 0 && is_opt then ( 
					 if !num  then os " (_,None)" else os " (d,None)";
				  )
				  else if (!var_pos = 0 || List.length ss = 0) && is_list then (
					 if !num then os "(_,[])" else os " (d,[])";
				  )
				  else print_pattern n
				in
				emit_pattern 0; os " -> let del' = !del in incr del; let _ = del' in ";
				
				let print_label constructor' =
				  let c = if(is_opt) then "\"Option\"" else if(is_list) then "cons" else ("\""^c^"\"") in
				  os constructor';
				  os "os \"[label=\\\"\"; os "; os c;
				  os "; os \"\\\"];\\n\"; ";
				in
				
				let const = 
				  if not is_opt then c
				  else (
					 let st = ref "" in 
					 String.iter(fun s -> 
						match s with
							 '`' -> () | _ -> st := ((!st)^(Char.escaped s)); ()
					 ) c; !st
				  )
				in
				let constructor = 
				  if is_list then "os cons; "
				  else "os \""^const^"\"; os (string_of_int del'); "
				in 

				if(not(!var_pos = 0 && is_list)) then (
				  let f = ref true in
				  let fir = ref true in
				  List.iter(fun (x1,n) ->
					 let x_i = 
						if Grammar.is_terminal x1 then (
						  if Grammar.is_in_ast t x1 then ("str"^string_of_int n) 
						  else ("pd"^string_of_int n)
						)
						else (symbol_var_name x1) ^ string_of_int n 
					 in
					 let string_of_terminal = if not (Grammar.is_in_ast t x1) then Grammar.string_of_terminal g x1 else "" in
					 let is_cur_eq_first_nt = (symbol_var_name x1) = symbol_var_name (s,false) in
					 let gviz_i = dump_nm^(symbol_var_name x1) in
					 
					 let rec is_first_list li =
						match li with
							 [] -> false
						  | (Grammar.Production(c,s,ss,ssop))::tl -> 
							 if (starts_with "List_Left" c || 
									 starts_with "List_Right" c) &&
								("gviz_"^s) = gviz_i then true
							 else is_first_list tl
					 in

					 
					 if Grammar.is_terminal x1 then (
						if not(!fir && is_list) then (
						  if(!f) then (os constructor; os " os \";\\n\"; ");
						) else os " os \";\\n\"; ";
						print_label constructor;
						os constructor; os " os \" -- \"; "; 
						os constructor; 
						os (" os (string_of_int del'); os \"_med"^(string_of_int !con)^";\\n\";");
						os constructor; 
						os (" os (string_of_int del'); os \"_med"^(string_of_int !con)^"[label=\\\"\"; ");
						incr con;

						if Grammar.is_in_ast t x1 then os " gviz_terminal os to_pretty_print ("
						else os (" os "^string_of_terminal)
					 )
					 else (
						if not (!fir && is_list) then (
						  if !f then (os constructor; os " os \";\\n\"; ");
						  print_label constructor; os constructor; os " os \" -- \";";
						);
						os gviz_i; os " os to_pretty_print ("
					 );

					 if !fir = true then fir := false;

					 let print_cons () =
						if is_first_list tl && not is_list then 
						  os ("\""^const^"\"^(string_of_int del')) ")
						else os "cons) ";
					 in

					 if is_cur_eq_first_nt && (is_list || is_opt) then (
						print_cons ();
						os (" (d,"^x_i^") ");
					 )
					 else if not (Grammar.is_terminal x1 && not (Grammar.is_in_ast t x1)) then (
						print_cons ();
						os x_i; 
					 );
					 
					 if Grammar.is_terminal x1 then 
						os "; os \"\\\"];\\n\"";
					 os "; ";
					 if !f then f := false;
				  ) ss';
				  
				  if !f then (
					 os constructor; os " os \";\\n\"; ";
					 os constructor;
					 os " os \"[label=\\\"None\\\"];\\n\"; "
				  )
				)
				else ( 
				  os constructor; os " os (string_of_int del');";
				  os (" os \"_med"^(string_of_int !con)^";\\n\"; ");
				  os constructor; os " os (string_of_int del');";
				  os (" os \"_med"^(string_of_int !con)^"[label=\\\"[]\\\"];\\n\"; ");
				);
				os " () ";  
			 in
			 let ssop = match ssop with None -> [] | Some(x) -> x in
			 prods ss; List.iter(prods) ssop; itr tl
	 in itr ps;
	 
	 if !num_same_nonterm > 1 then os ""; os ";;\n";
	 os ("\nlet gviz (os:string->unit) (to_pretty_print:bool) (cons:string) e = os "^
			  "\"graph hopeful { \\nnode [shape=\\\"plaintext\\\"];\\n\"; gviz_" ^ 
			  symbol_var_name (Grammar.get_start_symbol g) ^ " os to_pretty_print cons e; os \"}\";;");
	 close_out ofile
;;
