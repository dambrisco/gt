Description of how to write in gtril
------------------------------------

Open and file Statements
------------------------
open f;
let (v:t) = "f";

   The f is the filename, the v is the variable name,
   and the t is the type. 

Type Statements
---------------
1. type v = V1;;
2. type v = V1 of t;;
3. type v = V1 of t1 * .. * tn;;
   type v = ts1| .. | tsn;;

   The word type is a keyword followed by a lowercase variable.
   The V1 is an uppercase variable and t,t1 through tn are all
   types. The ts1 through tsn are all type statements in the 
   form of 1,2,or 3. 
 

Global Variables
----------------
t v1 .. vn;

   The t is the type and v1 through vn are the variables
   all separated by whitespace.

Non-Global Variable
-------------------
let (v1:t1) .. (vn:tn) = e;
let (v1:t1) .. (vn:tn) = e1 in e2;
   
    The v1:t1 through vn:tn are all variables with their 
    type. The e, e1, and e2 are all expressions. The e2
    is the body of the let. The variable is defined as the
    value of e1 with the body. The variable is defined only
    in the body e2 and not e1.

Dot variables
-------------
V.e

   The V is a variable beginning with a captital letter
   followed by a dot and then an expression.

examples - String.length (str)
           Str.[len - i - 1] 

List type
---------
list type
   
   List type is always used with keyword list followed by 
   whitespace then the type. The empty list is written as
   [nil type].

List cons
---------
(cons e1 ...cons en [nil type])

    The cons is a keyword used as a prefix to el through en
    which are expressions.

Empty List
----------
[nil t]

    The nil is a keyword and the t is the type.

Non-recursive functions
-----------------------
let f p1..pn : rt = b;;

   The f is the function name. The a1 through an are parameters 
   written (v:t) where v is the variablename and t is the type
   and rt is used as the return type for the function. 
   The b is the body of the function.

Recursive functions
-------------------
let rec f p1..pn : rt = b;; 

   The f is the function name. The p1 through pn are parameters 
   written (v:t) where v is the variablename and t is the type
   and rt is used as the return type for the function. 
   The b is the body of the function. The f can also be used in
   b unlike the non-recursive function which it can't.

Function calls
--------------
(f a1 .. an)

   The f is the function name and the a1 through an are the arguments.
   The arguments are separated by whitespace.

If then else statements
----------------------- 
if (t) then {b};
if (t) then {b} e1{b1} .. en{bn};

   The t is the test. The b is the body of the then and the e1{b1} through 
   the en{bn} are the elses each with their own bodies.

Match statements
----------------
match e with
    p1 -> e1
  | p2 -> e2
  .
  .
  | pn -> en

   The e1,e2, through en are all expressions. The p1,p2, through pn are
   all patterns. Nested patterns will not be allowed(nested usues of the
   entire pattern-matching construct will have to be used instead).

For loop
--------
for v = i to e do b; done;

   The v is a variable, i is an integer, e is an expression and b is the
   body. The for, to, do, done are all keywords.

example - for i = 0 to len - 1 do 
          Buffer.add_char (buf) Str.[len - i -1];  
          done;

-----------------------------------------------------------------------------------

Examples of gtril vs ocaml
--------------------------
gtril function
--------------

let rec get_string_list_from_string (i:int) (s:string) (l:list char):list char =
    if (String.length (s) > i) then
   {(get_string_list_from_string (i+1) s (i-2) (cons l@s.[i] [nil char]) );}
    else 
       {l;};;


Same function written in ocaml
------------------------------

let rec get_string_list_from_string (i) (s) (l) =
    if(String.length s > i) then
    (get_string_list_from_string (i+1) s (l@s.[i]::[]))
    else (l);;



gtril function
--------------

let list_lt (l:list int) (x:int):boolean =
    let (f:fun) (y:int) =
         x > y in
         List.fold_right (&) (List.map (f l)) (true);;


Same function written in ocaml
------------------------------

let list_lt l (x:int) =
    let f y =
         x > y in
         List.fold_right (&) (List.map f l) true;;



gtril function
--------------

type day = Sunday  | Monday | Tuesday | Wednesday | Thursday | Friday |  Saturday;;

let rec next_day (i:string) (num:int):string =
	if (num = 0) then
		{i;}

	else if (num > 0) then
		{let i = match i with
		 	 	  Sunday -> Monday
				| Monday -> Tuesday
				| Tuesday -> Wednesday
				| Wednesday -> Thursday
				| Thursday -> Friday
				| Friday -> Saturday
				| Saturday -> Sunday in

		(next_day i (num -1));}

	else 
		{let i = match i with
		 	 	  Sunday -> Saturday
				| Saturday -> Friday
				| Friday -> Thursday
				| Thursday -> Wednesday
				| Wednesday -> Tuesday
				| Tuesday -> Monday
				| Monday -> Sunday in 

		(next_day i (num + 1));};;


Same function written in ocaml
------------------------------

type day = Sunday  | Monday | Tuesday | Wednesday | Thursday | Friday |  Saturday;;

let rec next_day i num =
	if num = 0 then
		i

	else if num > 0 then
		let i = (match i with
		 	 	  Sunday -> Monday
				| Monday -> Tuesday
				| Tuesday -> Wednesday
				| Wednesday -> Thursday
				| Thursday -> Friday
				| Friday -> Saturday
				| Saturday -> Sunday) in

		next_day i (num - 1)

	else 
		let i = (match i with
		 	 	  Sunday -> Saturday
				| Saturday -> Friday
				| Friday -> Thursday
				| Thursday -> Wednesday
				| Wednesday -> Tuesday
				| Tuesday -> Monday
				| Monday -> Sunday) in 

		next_day i (num + 1);;


